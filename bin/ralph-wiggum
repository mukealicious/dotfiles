#!/bin/sh
#
# ralph-wiggum
#
# Automated PRD task runner. Calls /complete-task repeatedly until all tasks
# are done or limit reached. Named after Ralph Wiggum because "Me fail English?
# That's unpossible!" - much like how this script stubbornly keeps trying.
#
# Usage: ralph-wiggum <prd-name> [--max N] [--dry-run]

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Defaults
MAX_TASKS=0  # 0 = unlimited
DRY_RUN=false
PRD_NAME=""
TASKS_COMPLETED=0
START_TIME=$(date +%s)

# Find dotfiles directory
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd -P)"
DOTFILES_DIR="$(cd "$(dirname "$SCRIPT_DIR")" && pwd -P)"

usage() {
    cat <<EOF
ralph-wiggum - Automated PRD task runner

Usage: ralph-wiggum <prd-name> [options]

Arguments:
  <prd-name>    Name of the PRD (matches .claude/state/<prd-name>/prd.json)

Options:
  --max N       Maximum number of tasks to complete (default: unlimited)
  --dry-run     Show what would be done without executing
  -h, --help    Show this help message

Examples:
  ralph-wiggum dotfiles-cleanup           # Complete all remaining tasks
  ralph-wiggum dotfiles-cleanup --max 3   # Complete at most 3 tasks
  ralph-wiggum dotfiles-cleanup --dry-run # Show tasks without running

EOF
    exit 0
}

error() {
    printf "${RED}Error:${NC} %s\n" "$1" >&2
    exit 1
}

info() {
    printf "${BLUE}→${NC} %s\n" "$1"
}

success() {
    printf "${GREEN}✓${NC} %s\n" "$1"
}

warn() {
    printf "${YELLOW}!${NC} %s\n" "$1"
}

# Parse arguments
while [ $# -gt 0 ]; do
    case "$1" in
        -h|--help)
            usage
            ;;
        --max)
            shift
            if [ -z "$1" ] || ! echo "$1" | grep -qE '^[0-9]+$'; then
                error "--max requires a positive integer"
            fi
            MAX_TASKS="$1"
            ;;
        --dry-run)
            DRY_RUN=true
            ;;
        -*)
            error "Unknown option: $1"
            ;;
        *)
            if [ -z "$PRD_NAME" ]; then
                PRD_NAME="$1"
            else
                error "Unexpected argument: $1"
            fi
            ;;
    esac
    shift
done

# Require PRD name
if [ -z "$PRD_NAME" ]; then
    usage
fi

# Find PRD state directory (walk up from cwd)
find_prd() {
    local prd="$1"
    local dir="$PWD"
    while [ "$dir" != "/" ]; do
        if [ -f "$dir/.claude/state/$prd/prd.json" ]; then
            echo "$dir/.claude/state/$prd"
            return 0
        fi
        dir="$(dirname "$dir")"
    done
    return 1
}

# List available PRDs
list_prds() {
    local dir="$PWD"
    while [ "$dir" != "/" ]; do
        if [ -d "$dir/.claude/state" ]; then
            find "$dir/.claude/state" -name "prd.json" -type f 2>/dev/null | while read -r f; do
                basename "$(dirname "$f")"
            done
            return 0
        fi
        dir="$(dirname "$dir")"
    done
}

# Get count of remaining tasks
get_remaining_tasks() {
    local prd_file="$1"
    jq '[.tasks[] | select(.passes == false)] | length' "$prd_file"
}

# Get next task info
get_next_task() {
    local prd_file="$1"
    jq -r '.tasks[] | select(.passes == false) | "\(.id): \(.description)"' "$prd_file" | head -1
}

# Execute a single task
execute_task() {
    local prd="$1"
    info "Running: claude /complete-task $prd"

    if [ "$DRY_RUN" = "true" ]; then
        warn "[dry-run] Would execute task"
        return 0
    fi

    # Run Claude with the complete-task skill
    if claude "/complete-task $prd"; then
        TASKS_COMPLETED=$((TASKS_COMPLETED + 1))
        return 0
    else
        return 1
    fi
}

# Show summary
show_summary() {
    local end_time=$(date +%s)
    local elapsed=$((end_time - START_TIME))
    local minutes=$((elapsed / 60))
    local seconds=$((elapsed % 60))

    echo ""
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    printf "${BLUE}Summary${NC}\n"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    printf "Tasks completed: ${GREEN}%d${NC}\n" "$TASKS_COMPLETED"
    printf "Time elapsed:    %dm %ds\n" "$minutes" "$seconds"

    if [ -n "$PRD_PATH" ] && [ -f "$PRD_PATH/prd.json" ]; then
        local remaining=$(get_remaining_tasks "$PRD_PATH/prd.json")
        printf "Tasks remaining: ${YELLOW}%d${NC}\n" "$remaining"
    fi
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
}

# Handle interrupt
cleanup() {
    echo ""
    warn "Interrupted!"
    show_summary
    exit 130
}

trap cleanup INT TERM

# Find PRD
PRD_PATH=$(find_prd "$PRD_NAME") || {
    error "PRD '$PRD_NAME' not found.

Available PRDs:
$(list_prds | sed 's/^/  - /')"
}

info "Found PRD at: $PRD_PATH"

# Main loop
remaining=$(get_remaining_tasks "$PRD_PATH/prd.json")
info "Tasks remaining: $remaining"

if [ "$remaining" -eq 0 ]; then
    success "All tasks already complete!"
    exit 0
fi

task_count=0
while true; do
    remaining=$(get_remaining_tasks "$PRD_PATH/prd.json")

    if [ "$remaining" -eq 0 ]; then
        echo ""
        success "All tasks complete!"
        break
    fi

    if [ "$MAX_TASKS" -gt 0 ] && [ "$task_count" -ge "$MAX_TASKS" ]; then
        echo ""
        warn "Reached maximum task limit ($MAX_TASKS)"
        break
    fi

    echo ""
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    printf "${BLUE}Task %d${NC} (remaining: %d)\n" "$((task_count + 1))" "$remaining"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

    next_task=$(get_next_task "$PRD_PATH/prd.json")
    info "Next: $next_task"

    if ! execute_task "$PRD_NAME"; then
        error "Task execution failed"
    fi

    task_count=$((task_count + 1))
done

show_summary
